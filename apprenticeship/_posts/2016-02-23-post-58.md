---
title: Factories explained with rock bands
comments: true
layout: apprenticeship-post
read-time: 5
category: apprenticeship
---

Jim asked me to write about the factory pattern during this week's iteration. And while I was at a gig last week, listening to the band, I thought about how I could best explain the different types of factories using my own examples. Of course! Using rock concerts!

<!--break-->

But firstly, what is a factory? Factories encapsulate object creation and are a good way to decouple clients from concrete classes. There are three different types of factories which I will explain in this post.

## Simple factory

A simple factory extracts the object creation from a class into a factory class whose only responsibility is to create a new instance of an object that the client class needs. 

Let's use a music festival as an example. Currently there are four bands available to play as headliners for the summer festivals this year. 

<pre><code class="language-java">
public class FestivalLineUp {

    public Headliner commissionSundayHeadliner(String bandName) {
      Headliner headliner;

        if (bandName.equals("The Dead Weather")) {
            headliner = new TheDeadWeatherHeadliner();
        } else if (bandName.equals("The Kills")) {
            headLiner = new TheKillsHeadliner();
        } else if (bandName.equals("Jack White")) {
            headliner = new JackWhiteHeadliner();
        }
        
        payDeposit(headLiner);
        headliner.getDietaryRequirements();
        headliner.getFavouriteAlcohol();
        // some more stuff to organise
    }

    public Headliner commissionSaturDayHeadliner() {
        // do some stuff
    }

    public Dj organiseDj() {
		// do some stuff
    }
    
    // some more methods that organise bands to play
}

</code></pre>

But what if suddenly Jack White doesn't have time anymore? Then we have to remove the Dead Weather and his solo gig from the list. Instead maybe Sleater Kinney suddenly become available, so they need to be added. Every time the band availabilities change, we have to change the `FestivalLineUp` class. 

It would be better if we extracted the band creation from the class instead and used a `HeadLinerFactory`. By doing it that way, the `FestivalLineUp` class is not impacted by any rock band diary changes.

Here's the new factory class.

<pre><code class="language-java">
public class HeadlinerFactory {

    public Headliner createHeadliner(String bandName) {
        Headliner headliner = null;

        if (bandName.equals("The Dead Weather")) {
            headliner = new TheDeadWeatherHeadliner();
        } else if (bandName.equals("The Kills")) {
            headliner = new TheKillsHeadliner();
        } else if (bandName.equals("Jack White")) {
            headliner = new JackWhiteHeadliner();
        }
        
        return headliner;
    }
}
</code></pre>

And the factory class gets injected as a dependency into the `FestivalLineUp` class and can then be used to create a new headliner. 

<pre><code class="language-java">

public class FestivalLineUp {
    private HeadlinerFactory headlinerFactory;

    public FestivalLineUp(HeadLinerFactory headLinerFactory) {
        this.headlinerFactory = headlinerFactory;
    }

    public HeadLiner commissionSundayHeadliner() {
        Headliner headliner;
        headliner = headlinerFactory.createHeadliner("PJ Harvey");
        payDeposit(headliner);
        headliner.getDietaryRequirements();
        headliner.getFavouriteAlcohol();
        // some more stuff to organise
    }
}
</code></pre>

Now the `FestivalLineUp` class has fewer dependencies and fewer reasons to change. The factory class should from now on be the only part of the application that refers to the various band sets.

## Factory method pattern

The intent of the factory method pattern is to allow a class to defer instantiation of new objects to its subclasses. It lets the subclasses decide which class to instantiate, based on their own class, while at the same time inheriting methods from the superclass.

I'll try to illustrate this with an example again. As you might know, over the last years a well-known mobile phone network has started to sponsor a lot of the London gig venues, including my local venue which is the Kentish Town Forum. 

Let's imagine that the Global Head of Gig Management at this mobile phone network has implemented a standard procedure which all of the venues have to follow. Once a new gig has been confirmed, the procedure includes that flyers have to be printed, the venue's own website has to be updated and ticket vendor websites have to be informed so that they can advertise the gig and sell tickets.

The band is selected by headoffice and then the venues need to do the marketing and other bits of preparation themselves. And the Global Head of Gig Management wants to make sure that the marketing is done right $$$. 

In this case we can use the factory method pattern to create a new instance of a gig for a band at a specific venue. The factory method will be declared as abstract in the base class and can then be implemented by any classes that subclass it (in this case the Kentish Town Forum). 

This is the base class for a new gig in one of the mobile network sponsored venues.

<pre><code class="language-java">
public abstract class MobileNetworkVenueGig {

    public void doMarketing() {
        Gig gig;
        gig = getGig("The Kills");
        printFlyers(gig);
        updateWebsite(gig);
        tellTicketVendors(gig);
    }

    protected abstract Gig getGig(String bandName);

    public void updateBarStaffRota(String date) {
        //make sure there's enough staff for the night
    }

    public void createGuestList() {
        //add NME journalists to guest list
    }
}

</code></pre>

And now this class can be extended by gigs at a specific gig venue, like the Kentish Town Forum. These venue specific classes inherit all the methods from the base class and implement the abstract method `getGig(String bandName)` themselves. That way, the Global Head of Gig Management can ensure that all gigs are set up following the same procedure.

The reason why we need to pass in the band name is because the bands are selected by head office. The venues themselves can't invite bands.

<pre><code class="language-java">
public class KentishTownForumGig extends MobileNetworkVenueGig {

    @Override
    protected Gig getGig(String bandName) {

        if (bandName.equals("The Kills")) {
            return new TheKillsAtKtForum();
        } else if (bandName.equals("BRMC")) {
            return new BrmcAtKtForum();
        } else if (bandName.equals("Temples")) {
            return new TemplesAtKtForum();
        } else {
            return null;
        }
    }
}
</code></pre>

Now you might wonder why we should structure our code in that way. An alternative would be to instead use an interface for `MobileNetworkVenueGig` and then the `KentishTownForumGig` could implement all the methods tailored to its own needs.

The downside of this is that we don't know how exactly the Kentish Town Forum will implement the methods. If we use an interface, we are only guaranteed that the subclasses will implement methods with a specific name and return type. But what actually happens inside those methods is uncontrollable. And the Global Head of Gig Management wouldn't be amused at all if for example the Forum forgot to tell one of the ticket vendor websites about the upcoming gig. By letting the Forum inherit all the methods, it can be ensured that they are implemented in exactly the same way for every venue.

## Abstract factory

The abstract factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.

It's best to show it using an example. This time the context is a band going on tour.

We have the `WorldTour` abstract class which prepares the tour, makes sure that the bands get to their gig venues, play gigs and attend the afterparty. 

<pre><code class="language-java">
public abstract class WorldTour {
    private SupportAct supportAct;
    private Roadie roadie;
    private TourBusDriver tourBusDriver;
    private FanClub fanClub;

    abstract void prepareTour();

    void travelTheWorld() {
       // travel to all the gig venues
    }

    void playGigs() {
        // play some gigs
    }

    void attendAfterParty() {
        // party hard
    }
}
</code></pre>

If The National want to go on a world tour, they just subclass the `WorldTour` class and get all the methods they need. The only thing they need to implement themselves is the tour preparation because they want to make sure that the prep is tailored to their exact needs. 

<pre><code class="language-java">
public class TheNationalTour extends WorldTour {
    EntourageFactory entourageFactory;

    public TheNationalTour(EntourageFactory entourageFactory) {
        this.entourageFactory = entourageFactory;
    }

    @Override
    void prepareTour() {
        supportAct = entourageFactory.createSupport();
        roadie = entourageFactory.createRoadie();
        tourBusDriver = entourageFactory.createTourBusDriver();
        fanClub = entourageFactory.createFanClub();
    }
}

</code></pre>

As you can see The National can use the `EntourageFactory` to create the entourage they need. The `EntourageFactory` in this case is the abstract factory. It's an interface which each specific band's world tour class has a dependency on.

<pre><code class="language-java">
public interface EntourageFactory {

    SupportAct createSupport();
    Roadie createRoadie();
    TourBusDriver createTourBusDriver();
    FanClub createFanClub();
}

</code></pre>

There's a concrete implementation of this factory interface for The National which is passed in at run time.

<pre><code class="language-java">
public class TheNationalEntourageFactory implements EntourageFactory {

    @Override
    public SupportAct createSupport() {
        return new TheNationalSupportAct();
    }

    @Override
    public Roadie createRoadie() {
        return new TheNationalRoadie();
    }

    @Override
    public TourBusDriver createTourBusDriver() {
        return new TheNationalBusDriver();
    }

    @Override
    public FanClub createFanClub() {
        return new TheNationalFanClub();
    }
}

</code></pre>

By using a structure like this, the entourage creation code is decoupled from the actual factory that creates the world tours. So if any particular band wants to change their bus driver, the `WorldTour` will never know and the `TheNationalTour` won't find out either.

## Advantages of factories

### Reusability

A factory has the advantage that it's reusable. So, using the festival headliners as an example again, if we wanted to instantiate more bands in a different place in our code, we can use the same factory class.

### Decoupling

Factories help with decoupling of classes. The places in the code that need an object don't need to know how to construct one. They can just rely on a factory class which has all that information. 

### Compiling without knowing the actual objects

Another advantage is that the places that need a specific object don't need to know at compile time which concrete class they will be using. The code will compile while using a factory as a placeholder and then at run time, the object that is needed will be created. 

### Extensibility

When another class needs to be added, for example if another band wants to go on a world tour, the calling classes including unit tests will not need to know. It's very easy to add a new class without changing huge chunks of existing code and the code thus adheres to the Open-Closed Principle.

### Easier unit-testing

When using a factory, we can write a test double for unit testing the calling code. We can test that the factory returns the correct objects separately and when testing the calling code we can either use a spy to check if the factory was called or we can stub out the factory to have a more basic implementation. 

### Any disadvantages?

It wouldn't be fair to mention advantages without looking into the disadvantages. But the only disadvantage that I could find was that factories make a codebase more complex to understand. So therefore they should only be used when necessary.